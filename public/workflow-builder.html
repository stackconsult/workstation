<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Workflow Builder - Browser Agent</title>
    <link rel="stylesheet" href="/css/workflow-builder.css">
    <!-- React and React-DOM from CDN for production -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Babel Standalone for JSX transformation (dev only - in prod, pre-compile) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    
    <!-- Workflow Builder React Application -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Node types available for workflow building
        const NODE_TYPES = {
            START: { type: 'start', label: 'Start', color: '#4CAF50', category: 'control' },
            NAVIGATE: { type: 'navigate', label: 'Navigate', color: '#2196F3', category: 'browser' },
            CLICK: { type: 'click', label: 'Click Element', color: '#FF9800', category: 'browser' },
            FILL: { type: 'fill', label: 'Fill Form', color: '#9C27B0', category: 'browser' },
            EXTRACT: { type: 'extract', label: 'Extract Data', color: '#00BCD4', category: 'browser' },
            WAIT: { type: 'wait', label: 'Wait', color: '#FFC107', category: 'browser' },
            CONDITION: { type: 'condition', label: 'Condition', color: '#F44336', category: 'control' },
            LOOP: { type: 'loop', label: 'Loop', color: '#E91E63', category: 'control' },
            
            // Data Agents
            CSV_PARSE: { type: 'csv_parse', label: 'Parse CSV', color: '#8BC34A', category: 'data' },
            CSV_WRITE: { type: 'csv_write', label: 'Write CSV', color: '#7CB342', category: 'data' },
            JSON_PARSE: { type: 'json_parse', label: 'Parse JSON', color: '#03A9F4', category: 'data' },
            JSON_QUERY: { type: 'json_query', label: 'Query JSON', color: '#0288D1', category: 'data' },
            EXCEL_READ: { type: 'excel_read', label: 'Read Excel', color: '#4CAF50', category: 'data' },
            EXCEL_WRITE: { type: 'excel_write', label: 'Write Excel', color: '#388E3C', category: 'data' },
            PDF_EXTRACT: { type: 'pdf_extract', label: 'Extract PDF', color: '#F44336', category: 'data' },
            PDF_GENERATE: { type: 'pdf_generate', label: 'Generate PDF', color: '#D32F2F', category: 'data' },
            
            // Integration Agents
            SHEETS_READ: { type: 'sheets_read', label: 'Read Sheet', color: '#34A853', category: 'integration' },
            SHEETS_WRITE: { type: 'sheets_write', label: 'Write Sheet', color: '#0F9D58', category: 'integration' },
            CALENDAR_CREATE: { type: 'calendar_create', label: 'Create Event', color: '#4285F4', category: 'integration' },
            CALENDAR_LIST: { type: 'calendar_list', label: 'List Events', color: '#1967D2', category: 'integration' },
            EMAIL_SEND: { type: 'email_send', label: 'Send Email', color: '#EA4335', category: 'integration' },
            EMAIL_READ: { type: 'email_read', label: 'Read Email', color: '#C5221F', category: 'integration' },
            
            // Storage Agents
            DATABASE_QUERY: { type: 'database_query', label: 'DB Query', color: '#FF9800', category: 'storage' },
            DATABASE_INSERT: { type: 'database_insert', label: 'DB Insert', color: '#F57C00', category: 'storage' },
            S3_UPLOAD: { type: 's3_upload', label: 'S3 Upload', color: '#FF6F00', category: 'storage' },
            S3_DOWNLOAD: { type: 's3_download', label: 'S3 Download', color: '#E65100', category: 'storage' },
            FILE_READ: { type: 'file_read', label: 'Read File', color: '#795548', category: 'storage' },
            FILE_WRITE: { type: 'file_write', label: 'Write File', color: '#5D4037', category: 'storage' },
            
            // Orchestration
            PARALLEL: { type: 'parallel', label: 'Parallel', color: '#9C27B0', category: 'orchestration' },
            
            END: { type: 'end', label: 'End', color: '#607D8B', category: 'control' }
        };

        // WorkflowNode Component
        function WorkflowNode({ node, onSelect, onDelete, isSelected }) {
            return (
                <div 
                    className={`workflow-node ${isSelected ? 'selected' : ''}`}
                    style={{ 
                        left: node.x, 
                        top: node.y,
                        backgroundColor: NODE_TYPES[node.type.toUpperCase()]?.color || '#ccc'
                    }}
                    onClick={() => onSelect(node)}
                >
                    <div className="node-header">
                        <span className="node-label">{node.label || NODE_TYPES[node.type.toUpperCase()]?.label}</span>
                        <button className="node-delete" onClick={(e) => { e.stopPropagation(); onDelete(node.id); }}>√ó</button>
                    </div>
                    {node.params && (
                        <div className="node-params">
                            {Object.entries(node.params).map(([key, value]) => (
                                <div key={key} className="node-param">
                                    <small>{key}: {String(value).substring(0, 20)}</small>
                                </div>
                            ))}
                        </div>
                    )}
                    <div className="node-connectors">
                        <div className="connector connector-input" data-node-id={node.id} data-type="input"></div>
                        <div className="connector connector-output" data-node-id={node.id} data-type="output"></div>
                    </div>
                </div>
            );
        }

        // NodeLibrary Component
        function NodeLibrary({ onAddNode }) {
            const [activeCategory, setActiveCategory] = useState('all');
            
            // Group nodes by category
            const categories = {
                all: 'All',
                control: 'Control',
                browser: 'Browser',
                data: 'Data',
                integration: 'Integration',
                storage: 'Storage',
                orchestration: 'Orchestration'
            };
            
            const filteredNodes = Object.entries(NODE_TYPES).filter(([key, nodeType]) => {
                if (activeCategory === 'all') return true;
                return nodeType.category === activeCategory;
            });
            
            return (
                <div className="node-library">
                    <h3>Node Library</h3>
                    <div className="node-categories">
                        {Object.entries(categories).map(([key, label]) => (
                            <button
                                key={key}
                                className={`category-btn ${activeCategory === key ? 'active' : ''}`}
                                onClick={() => setActiveCategory(key)}
                            >
                                {label}
                            </button>
                        ))}
                    </div>
                    <div className="node-library-items">
                        {filteredNodes.map(([key, nodeType]) => (
                            <button
                                key={key}
                                className="node-library-item"
                                style={{ backgroundColor: nodeType.color }}
                                onClick={() => onAddNode(nodeType.type)}
                                title={`Add ${nodeType.label} node`}
                            >
                                {nodeType.label}
                            </button>
                        ))}
                    </div>
                </div>
            );
        }

        // TemplateGallery Component
        function TemplateGallery({ onLoadTemplate }) {
            const [templates, setTemplates] = useState([]);
            const [categories, setCategories] = useState([]);
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [searchQuery, setSearchQuery] = useState('');
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                fetchTemplates();
            }, []);

            const fetchTemplates = async () => {
                try {
                    const response = await fetch('/api/workflow-templates');
                    const result = await response.json();
                    if (result.success) {
                        setTemplates(result.data.templates);
                        setCategories(result.data.categories);
                    }
                } catch (error) {
                    console.error('Failed to fetch templates:', error);
                } finally {
                    setLoading(false);
                }
            };

            const filteredTemplates = templates.filter(template => {
                const matchesCategory = selectedCategory === 'all' || template.category === selectedCategory;
                const matchesSearch = !searchQuery || 
                    template.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    template.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    template.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()));
                return matchesCategory && matchesSearch;
            });

            const getComplexityColor = (complexity) => {
                switch(complexity) {
                    case 'beginner': return '#4CAF50';
                    case 'intermediate': return '#FF9800';
                    case 'advanced': return '#F44336';
                    default: return '#9E9E9E';
                }
            };

            return (
                <div className="template-gallery">
                    <div className="template-header">
                        <h3>üìö Workflow Templates</h3>
                        <input 
                            type="text"
                            className="template-search"
                            placeholder="Search templates..."
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                        />
                    </div>

                    <div className="template-categories">
                        <button
                            className={`category-btn ${selectedCategory === 'all' ? 'active' : ''}`}
                            onClick={() => setSelectedCategory('all')}
                        >
                            All Templates ({templates.length})
                        </button>
                        {categories.map(cat => (
                            <button
                                key={cat.id}
                                className={`category-btn ${selectedCategory === cat.id ? 'active' : ''}`}
                                onClick={() => setSelectedCategory(cat.id)}
                            >
                                {cat.icon} {cat.name} ({cat.templateCount})
                            </button>
                        ))}
                    </div>

                    <div className="template-list">
                        {loading ? (
                            <div className="template-loading">Loading templates...</div>
                        ) : filteredTemplates.length === 0 ? (
                            <div className="template-empty">No templates found</div>
                        ) : (
                            filteredTemplates.map(template => (
                                <div key={template.id} className="template-card">
                                    <div className="template-card-header">
                                        <span className="template-icon">{template.icon}</span>
                                        <h4 className="template-name">{template.name}</h4>
                                        <span 
                                            className="template-complexity"
                                            style={{ backgroundColor: getComplexityColor(template.complexity) }}
                                        >
                                            {template.complexity}
                                        </span>
                                    </div>
                                    <p className="template-description">{template.description}</p>
                                    <div className="template-meta">
                                        <span className="template-duration">‚è±Ô∏è {template.estimatedDuration}</span>
                                        <span className="template-nodes">üì¶ {template.nodes.length} nodes</span>
                                    </div>
                                    <div className="template-tags">
                                        {template.tags.map(tag => (
                                            <span key={tag} className="template-tag">{tag}</span>
                                        ))}
                                    </div>
                                    <button 
                                        className="btn btn-primary template-use-btn"
                                        onClick={() => onLoadTemplate(template)}
                                    >
                                        Use Template
                                    </button>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        }

        // NodeProperties Component
        function NodeProperties({ node, onUpdate, onClose }) {
            const [params, setParams] = useState(node?.params || {});

            useEffect(() => {
                setParams(node?.params || {});
            }, [node]);

            if (!node) {
                return (
                    <div className="node-properties">
                        <div className="properties-empty">
                            Select a node to edit its properties
                        </div>
                    </div>
                );
            }

            const handleParamChange = (key, value) => {
                const updated = { ...params, [key]: value };
                setParams(updated);
                onUpdate(node.id, updated);
            };

            const getParamFields = () => {
                switch (node.type) {
                    case 'navigate':
                        return [
                            { key: 'url', label: 'URL', type: 'text', placeholder: 'https://example.com' }
                        ];
                    case 'click':
                        return [
                            { key: 'selector', label: 'CSS Selector', type: 'text', placeholder: '#button' }
                        ];
                    case 'fill':
                        return [
                            { key: 'selector', label: 'CSS Selector', type: 'text', placeholder: '#input' },
                            { key: 'value', label: 'Value', type: 'text', placeholder: 'text to fill' }
                        ];
                    case 'extract':
                        return [
                            { key: 'selector', label: 'CSS Selector', type: 'text', placeholder: '.data' },
                            { key: 'attribute', label: 'Attribute', type: 'text', placeholder: 'textContent' }
                        ];
                    case 'wait':
                        return [
                            { key: 'duration', label: 'Duration (ms)', type: 'number', placeholder: '1000' }
                        ];
                    case 'condition':
                        return [
                            { key: 'condition', label: 'Condition', type: 'text', placeholder: 'data === "expected"' }
                        ];
                    default:
                        return [];
                }
            };

            return (
                <div className="node-properties">
                    <div className="properties-header">
                        <h3>Node Properties</h3>
                        <button className="close-btn" onClick={onClose}>√ó</button>
                    </div>
                    <div className="properties-content">
                        <div className="property-group">
                            <label>Node Type</label>
                            <input type="text" value={node.type} disabled />
                        </div>
                        <div className="property-group">
                            <label>Label</label>
                            <input 
                                type="text" 
                                value={node.label || ''} 
                                onChange={(e) => onUpdate(node.id, params, e.target.value)}
                                placeholder="Node label"
                            />
                        </div>
                        {getParamFields().map(field => (
                            <div key={field.key} className="property-group">
                                <label>{field.label}</label>
                                <input
                                    type={field.type}
                                    value={params[field.key] || ''}
                                    onChange={(e) => handleParamChange(field.key, e.target.value)}
                                    placeholder={field.placeholder}
                                />
                            </div>
                        ))}
                    </div>
                </div>
            );
        }

        // Canvas Component with D3 visualization
        function Canvas({ nodes, connections, onCanvasClick, selectedNode }) {
            const canvasRef = useRef(null);
            const svgRef = useRef(null);

            useEffect(() => {
                if (!svgRef.current) return;

                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();

                // Draw connections
                const g = svg.append("g");
                
                connections.forEach(conn => {
                    const fromNode = nodes.find(n => n.id === conn.from);
                    const toNode = nodes.find(n => n.id === conn.to);
                    
                    if (fromNode && toNode) {
                        // Calculate connection points
                        const x1 = fromNode.x + 100; // Node width/2
                        const y1 = fromNode.y + 40; // Node height
                        const x2 = toNode.x + 100;
                        const y2 = toNode.y;

                        // Draw curved path
                        const path = `M ${x1} ${y1} C ${x1} ${y1 + 30}, ${x2} ${y2 - 30}, ${x2} ${y2}`;
                        
                        g.append("path")
                            .attr("d", path)
                            .attr("stroke", "#666")
                            .attr("stroke-width", 2)
                            .attr("fill", "none")
                            .attr("marker-end", "url(#arrowhead)");
                    }
                });

                // Arrow marker
                svg.append("defs").append("marker")
                    .attr("id", "arrowhead")
                    .attr("markerWidth", 10)
                    .attr("markerHeight", 10)
                    .attr("refX", 5)
                    .attr("refY", 3)
                    .attr("orient", "auto")
                    .append("polygon")
                    .attr("points", "0 0, 10 3, 0 6")
                    .attr("fill", "#666");

            }, [nodes, connections]);

            return (
                <div ref={canvasRef} className="workflow-canvas" onClick={onCanvasClick}>
                    <svg ref={svgRef} className="connections-svg" />
                </div>
            );
        }

        // Main WorkflowBuilder Component
        function WorkflowBuilder() {
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [selectedNode, setSelectedNode] = useState(null);
            const [workflowName, setWorkflowName] = useState('Untitled Workflow');
            const [isDragging, setIsDragging] = useState(false);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [nextNodeId, setNextNodeId] = useState(1);
            const [currentWorkflowId, setCurrentWorkflowId] = useState(null);
            const [isExecuting, setIsExecuting] = useState(false);
            const [executionStatus, setExecutionStatus] = useState(null);
            const [executionHistory, setExecutionHistory] = useState([]);
            const [showHistory, setShowHistory] = useState(false);
            const [activeTab, setActiveTab] = useState('builder'); // 'builder' or 'templates'

            const addNode = (type) => {
                const newNode = {
                    id: `node-${nextNodeId}`,
                    type: type,
                    label: NODE_TYPES[type.toUpperCase()]?.label,
                    x: 100 + (nextNodeId * 20),
                    y: 100 + (nextNodeId * 20),
                    params: {}
                };
                setNodes([...nodes, newNode]);
                setNextNodeId(nextNodeId + 1);
                setSelectedNode(newNode);
            };

            const deleteNode = (nodeId) => {
                setNodes(nodes.filter(n => n.id !== nodeId));
                setConnections(connections.filter(c => c.from !== nodeId && c.to !== nodeId));
                if (selectedNode?.id === nodeId) {
                    setSelectedNode(null);
                }
            };

            const updateNodeParams = (nodeId, params, label) => {
                setNodes(nodes.map(node => 
                    node.id === nodeId 
                        ? { ...node, params, label: label !== undefined ? label : node.label }
                        : node
                ));
            };

            const handleCanvasClick = (e) => {
                if (e.target.className === 'workflow-canvas' || e.target.className === 'connections-svg') {
                    setSelectedNode(null);
                }
            };

            const getToken = () => {
                return localStorage.getItem('authToken') || '';
            };

            const convertNodesToWorkflow = () => {
                // Convert visual builder nodes to backend workflow format
                const tasks = nodes.map(node => {
                    const task = {
                        name: node.label || node.type,
                        agent_type: 'browser',
                        action: node.type,
                        parameters: {}
                    };

                    // Map node parameters to task parameters based on agent type
                    switch (node.type) {
                        // Browser actions
                        case 'navigate':
                            task.parameters = { url: node.params.url || 'https://example.com' };
                            break;
                        case 'click':
                            task.parameters = { selector: node.params.selector || 'button' };
                            break;
                        case 'fill':
                            task.parameters = { 
                                selector: node.params.selector || 'input',
                                text: node.params.value || ''
                            };
                            task.action = 'type';
                            break;
                        case 'extract':
                            task.parameters = { 
                                selector: node.params.selector || 'body'
                            };
                            task.action = 'getText';
                            break;
                        case 'wait':
                            task.parameters = { 
                                duration: parseInt(node.params.duration) || 1000
                            };
                            break;
                        case 'condition':
                            task.parameters = { 
                                condition: node.params.condition || 'true'
                            };
                            task.action = 'evaluate';
                            break;
                        
                        // CSV agent
                        case 'csv_parse':
                            task.agent_type = 'csv';
                            task.action = 'parseCsv';
                            task.parameters = { 
                                input: node.params.input || '',
                                hasHeader: node.params.hasHeader !== false
                            };
                            break;
                        case 'csv_write':
                            task.agent_type = 'csv';
                            task.action = 'writeCsv';
                            task.parameters = { 
                                data: node.params.data || [],
                                includeHeader: node.params.includeHeader !== false
                            };
                            break;
                        
                        // JSON agent
                        case 'json_parse':
                            task.agent_type = 'json';
                            task.action = 'parseJson';
                            task.parameters = { 
                                input: node.params.input || '{}'
                            };
                            break;
                        case 'json_query':
                            task.agent_type = 'json';
                            task.action = 'queryJson';
                            task.parameters = { 
                                data: node.params.data || {},
                                query: node.params.query || '$'
                            };
                            break;
                        
                        // Excel agent
                        case 'excel_read':
                            task.agent_type = 'excel';
                            task.action = 'readExcel';
                            task.parameters = { 
                                filePath: node.params.filePath || '',
                                sheetName: node.params.sheetName
                            };
                            break;
                        case 'excel_write':
                            task.agent_type = 'excel';
                            task.action = 'writeExcel';
                            task.parameters = { 
                                data: node.params.data || [],
                                sheetName: node.params.sheetName || 'Sheet1'
                            };
                            break;
                        
                        // PDF agent
                        case 'pdf_extract':
                            task.agent_type = 'pdf';
                            task.action = 'extractText';
                            task.parameters = { 
                                filePath: node.params.filePath || ''
                            };
                            break;
                        case 'pdf_generate':
                            task.agent_type = 'pdf';
                            task.action = 'generatePdf';
                            task.parameters = { 
                                content: node.params.content || '',
                                outputPath: node.params.outputPath || ''
                            };
                            break;
                        
                        // Google Sheets agent
                        case 'sheets_read':
                            task.agent_type = 'sheets';
                            task.action = 'readSheet';
                            task.parameters = { 
                                spreadsheetId: node.params.spreadsheetId || '',
                                range: node.params.range || 'Sheet1!A1:Z100'
                            };
                            break;
                        case 'sheets_write':
                            task.agent_type = 'sheets';
                            task.action = 'writeSheet';
                            task.parameters = { 
                                spreadsheetId: node.params.spreadsheetId || '',
                                range: node.params.range || 'Sheet1!A1',
                                values: node.params.values || [[]]
                            };
                            break;
                        
                        // Google Calendar agent
                        case 'calendar_create':
                            task.agent_type = 'calendar';
                            task.action = 'createEvent';
                            task.parameters = { 
                                summary: node.params.summary || 'New Event',
                                start: node.params.start || new Date().toISOString(),
                                end: node.params.end || new Date(Date.now() + 3600000).toISOString()
                            };
                            break;
                        case 'calendar_list':
                            task.agent_type = 'calendar';
                            task.action = 'listEvents';
                            task.parameters = { 
                                timeMin: node.params.timeMin || new Date().toISOString(),
                                maxResults: node.params.maxResults || 10
                            };
                            break;
                        
                        // Email agent
                        case 'email_send':
                            task.agent_type = 'email';
                            task.action = 'sendEmail';
                            task.parameters = { 
                                to: node.params.to || '',
                                subject: node.params.subject || '',
                                body: node.params.body || ''
                            };
                            break;
                        case 'email_read':
                            task.agent_type = 'email';
                            task.action = 'getUnreadEmails';
                            task.parameters = { 
                                maxResults: node.params.maxResults || 10
                            };
                            break;
                        
                        // Database agent
                        case 'database_query':
                            task.agent_type = 'database';
                            task.action = 'query';
                            task.parameters = { 
                                sql: node.params.sql || 'SELECT 1',
                                params: node.params.params || []
                            };
                            break;
                        case 'database_insert':
                            task.agent_type = 'database';
                            task.action = 'insert';
                            task.parameters = { 
                                table: node.params.table || '',
                                data: node.params.data || {}
                            };
                            break;
                        
                        // S3 agent
                        case 's3_upload':
                            task.agent_type = 's3';
                            task.action = 'uploadFile';
                            task.parameters = { 
                                key: node.params.key || '',
                                content: node.params.content || ''
                            };
                            break;
                        case 's3_download':
                            task.agent_type = 's3';
                            task.action = 'downloadFile';
                            task.parameters = { 
                                key: node.params.key || ''
                            };
                            break;
                        
                        // File agent
                        case 'file_read':
                            task.agent_type = 'file';
                            task.action = 'readFile';
                            task.parameters = { 
                                path: node.params.path || ''
                            };
                            break;
                        case 'file_write':
                            task.agent_type = 'file';
                            task.action = 'writeFile';
                            task.parameters = { 
                                path: node.params.path || '',
                                content: node.params.content || ''
                            };
                            break;
                        
                        // Parallel execution
                        case 'parallel':
                            task.agent_type = 'orchestration';
                            task.action = 'parallel';
                            task.parameters = { 
                                tasks: node.params.tasks || []
                            };
                            break;
                        
                        default:
                            task.parameters = node.params || {};
                    }

                    return task;
                });

                return {
                    tasks,
                    variables: {},
                    on_error: 'stop'
                };
            };

            const exportWorkflow = () => {
                const workflow = {
                    name: workflowName,
                    version: '1.0',
                    nodes: nodes,
                    connections: connections,
                    createdAt: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(workflow, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${workflowName.replace(/\s+/g, '-').toLowerCase()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const importWorkflow = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const workflow = JSON.parse(event.target.result);
                        setWorkflowName(workflow.name || 'Imported Workflow');
                        setNodes(workflow.nodes || []);
                        setConnections(workflow.connections || []);
                        setNextNodeId(Math.max(...(workflow.nodes?.map(n => parseInt(n.id.split('-')[1])) || [0])) + 1);
                    } catch (error) {
                        alert('Failed to import workflow: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };

            const loadTemplate = (template) => {
                if (nodes.length > 0) {
                    if (!confirm('Loading a template will replace your current workflow. Continue?')) {
                        return;
                    }
                }
                
                setWorkflowName(template.name);
                setNodes(template.nodes || []);
                setConnections(template.connections || []);
                setNextNodeId(Math.max(...(template.nodes?.map(n => parseInt(n.id.split('-')[1])) || [0])) + 1);
                setActiveTab('builder'); // Switch to builder view
                setExecutionStatus({
                    status: 'success',
                    message: `Template "${template.name}" loaded successfully! Customize the parameters and execute when ready.`
                });
                
                // Clear success message after 5 seconds
                setTimeout(() => setExecutionStatus(null), 5000);
            };

            const saveWorkflow = async () => {
                if (nodes.length === 0) {
                    alert('Please add some nodes to the workflow first');
                    return;
                }

                const workflowDefinition = convertNodesToWorkflow();
                const workflow = {
                    name: workflowName,
                    description: `Visual workflow with ${nodes.length} nodes`,
                    definition: workflowDefinition
                };

                try {
                    const token = getToken();
                    if (!token) {
                        alert('Please login first. Token not found in localStorage.');
                        return;
                    }

                    const response = await fetch('/api/v2/workflows', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(workflow)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        setCurrentWorkflowId(result.data.id);
                        alert('Workflow saved successfully!');
                    } else {
                        const error = await response.json();
                        alert('Failed to save workflow: ' + (error.error || response.statusText));
                    }
                } catch (error) {
                    alert('Error saving workflow: ' + error.message);
                }
            };

            const executeWorkflow = async () => {
                if (nodes.length === 0) {
                    alert('Please add some nodes to the workflow first');
                    return;
                }

                setIsExecuting(true);
                setExecutionStatus({ status: 'starting', message: 'Starting workflow execution...' });

                try {
                    const token = getToken();
                    if (!token) {
                        alert('Please login first. Token not found in localStorage.');
                        setIsExecuting(false);
                        return;
                    }

                    let workflowId = currentWorkflowId;

                    // If no workflow ID, create workflow first
                    if (!workflowId) {
                        const workflowDefinition = convertNodesToWorkflow();
                        const workflow = {
                            name: workflowName,
                            description: `Visual workflow with ${nodes.length} nodes`,
                            definition: workflowDefinition
                        };

                        const createResponse = await fetch('/api/v2/workflows', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify(workflow)
                        });

                        if (!createResponse.ok) {
                            throw new Error('Failed to create workflow');
                        }

                        const createResult = await createResponse.json();
                        workflowId = createResult.data.id;
                        setCurrentWorkflowId(workflowId);
                    }

                    // Execute workflow
                    const executeResponse = await fetch(`/api/v2/workflows/${workflowId}/execute`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ variables: {} })
                    });

                    if (!executeResponse.ok) {
                        throw new Error('Failed to execute workflow');
                    }

                    const executeResult = await executeResponse.json();
                    const executionId = executeResult.data.id;

                    // Start polling for status
                    pollExecutionStatus(executionId);
                } catch (error) {
                    setIsExecuting(false);
                    setExecutionStatus({ status: 'error', message: 'Execution failed: ' + error.message });
                }
            };

            const pollExecutionStatus = async (executionId) => {
                const token = getToken();
                const maxPolls = 120; // 2 minutes max
                let pollCount = 0;

                const poll = async () => {
                    try {
                        const response = await fetch(`/api/v2/executions/${executionId}/status`, {
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (!response.ok) {
                            throw new Error('Failed to get execution status');
                        }

                        const result = await response.json();
                        const { status, progress, error_message } = result.data;

                        setExecutionStatus({ 
                            status, 
                            message: `Status: ${status} (${progress}%)`,
                            progress,
                            error: error_message
                        });

                        if (status === 'completed') {
                            setIsExecuting(false);
                            // Get logs and add to history
                            await fetchExecutionLogs(executionId);
                            loadExecutionHistory();
                            return;
                        } else if (status === 'failed') {
                            setIsExecuting(false);
                            await fetchExecutionLogs(executionId);
                            loadExecutionHistory();
                            return;
                        } else if (pollCount < maxPolls) {
                            pollCount++;
                            // Exponential backoff: start at 1s, double up to 8s max
                            const delay = Math.min(1000 * Math.pow(2, Math.floor(pollCount / 3)), 8000);
                            setTimeout(poll, delay);
                        } else {
                            setIsExecuting(false);
                            setExecutionStatus({ status: 'timeout', message: 'Execution timed out' });
                        }
                    } catch (error) {
                        setIsExecuting(false);
                        setExecutionStatus({ status: 'error', message: error.message });
                    }
                };

                poll();
            };

            const fetchExecutionLogs = async (executionId) => {
                const token = getToken();
                try {
                    const response = await fetch(`/api/v2/executions/${executionId}/logs`, {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        setExecutionStatus(prev => ({
                            ...prev,
                            logs: result.data.logs
                        }));
                    }
                } catch (error) {
                    console.error('Failed to fetch logs:', error);
                }
            };

            const loadExecutionHistory = async () => {
                const token = getToken();
                if (!token) return;

                try {
                    const response = await fetch('/api/v2/workflows', {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        setExecutionHistory(result.data || []);
                    }
                } catch (error) {
                    console.error('Failed to load history:', error);
                }
            };

            useEffect(() => {
                loadExecutionHistory();
            }, []);

            return (
                <div className="workflow-builder">
                    <div className="builder-header">
                        <div className="header-left">
                            <h1>Visual Workflow Builder</h1>
                            <input 
                                type="text" 
                                className="workflow-name-input"
                                value={workflowName}
                                onChange={(e) => setWorkflowName(e.target.value)}
                                placeholder="Workflow Name"
                            />
                        </div>
                        <div className="header-right">
                            <button className="btn btn-secondary" onClick={() => setNodes([])}>Clear</button>
                            <label className="btn btn-secondary">
                                Import
                                <input type="file" accept=".json" onChange={importWorkflow} style={{display: 'none'}} />
                            </label>
                            <button className="btn btn-secondary" onClick={exportWorkflow}>Export</button>
                            <button className="btn btn-primary" onClick={saveWorkflow}>Save</button>
                            <button className="btn btn-success" onClick={executeWorkflow} disabled={isExecuting}>
                                {isExecuting ? '‚è≥ Executing...' : 'üöÄ Execute'}
                            </button>
                            <button className="btn btn-info" onClick={() => setShowHistory(!showHistory)}>
                                üìä History
                            </button>
                        </div>
                    </div>

                    {/* Tab Navigation */}
                    <div className="tab-navigation">
                        <button 
                            className={`tab-btn ${activeTab === 'builder' ? 'active' : ''}`}
                            onClick={() => setActiveTab('builder')}
                        >
                            üîß Workflow Builder
                        </button>
                        <button 
                            className={`tab-btn ${activeTab === 'templates' ? 'active' : ''}`}
                            onClick={() => setActiveTab('templates')}
                        >
                            üìö Templates
                        </button>
                    </div>
                    
                    {executionStatus && (
                        <div className={`execution-status status-${executionStatus.status}`}>
                            <strong>{executionStatus.message}</strong>
                            {executionStatus.progress && (
                                <div className="progress-bar">
                                    <div className="progress-fill" style={{ width: `${executionStatus.progress}%` }}></div>
                                </div>
                            )}
                            {executionStatus.error && (
                                <div className="error-message">Error: {executionStatus.error}</div>
                            )}
                            {executionStatus.logs && (
                                <details className="logs-details">
                                    <summary>View Logs ({executionStatus.logs.length} entries)</summary>
                                    <div className="logs-container">
                                        {executionStatus.logs.map((log, idx) => (
                                            <div key={idx} className={`log-entry log-${log.level}`}>
                                                <span className="log-time">{new Date(log.timestamp).toLocaleTimeString()}</span>
                                                <span className="log-message">{log.message}</span>
                                            </div>
                                        ))}
                                    </div>
                                </details>
                            )}
                        </div>
                    )}
                    
                    {/* Conditional rendering based on active tab */}
                    {activeTab === 'templates' ? (
                        <TemplateGallery onLoadTemplate={loadTemplate} />
                    ) : (
                        <div className="builder-main">
                            <NodeLibrary onAddNode={addNode} />
                            
                            <div className="builder-workspace">
                                <Canvas 
                                    nodes={nodes}
                                    connections={connections}
                                    onCanvasClick={handleCanvasClick}
                                    selectedNode={selectedNode}
                                />
                                {nodes.map(node => (
                                    <WorkflowNode
                                        key={node.id}
                                        node={node}
                                    onSelect={setSelectedNode}
                                    onDelete={deleteNode}
                                    isSelected={selectedNode?.id === node.id}
                                />
                            ))}
                        </div>
                        
                        <NodeProperties
                            node={selectedNode}
                            onUpdate={updateNodeParams}
                            onClose={() => setSelectedNode(null)}
                        />
                        </div>
                    )}

                    {showHistory && (
                        <div className="history-panel">
                            <div className="history-header">
                                <h3>Execution History</h3>
                                <button className="btn btn-secondary" onClick={() => setShowHistory(false)}>Close</button>
                            </div>
                            <div className="history-list">
                                {executionHistory.length === 0 ? (
                                    <div className="history-empty">No workflow history yet</div>
                                ) : (
                                    executionHistory.map(workflow => (
                                        <div key={workflow.id} className="history-item">
                                            <div className="history-item-name">{workflow.name}</div>
                                            <div className="history-item-time">{new Date(workflow.created_at).toLocaleString()}</div>
                                            <div className="history-item-status">{workflow.status}</div>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>
                    )}

                    <div className="builder-footer">
                        <div className="footer-stats">
                            <span>Nodes: {nodes.length}</span>
                            <span>Connections: {connections.length}</span>
                            {currentWorkflowId && <span>ID: {currentWorkflowId.substring(0, 8)}...</span>}
                        </div>
                        <div className="footer-actions">
                            <button className="btn-link" onClick={() => window.location.href = '/dashboard.html'}>
                                Back to Dashboard
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // Render the app
        ReactDOM.render(<WorkflowBuilder />, document.getElementById('root'));
    </script>
</body>
</html>
