<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Workflow Builder - Browser Agent</title>
    <link rel="stylesheet" href="/css/workflow-builder.css">
    <!-- React and React-DOM from CDN for production -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Babel Standalone for JSX transformation (dev only - in prod, pre-compile) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    
    <!-- Workflow Builder React Application -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Node types available for workflow building
        const NODE_TYPES = {
            START: { type: 'start', label: 'Start', color: '#4CAF50' },
            NAVIGATE: { type: 'navigate', label: 'Navigate', color: '#2196F3' },
            CLICK: { type: 'click', label: 'Click Element', color: '#FF9800' },
            FILL: { type: 'fill', label: 'Fill Form', color: '#9C27B0' },
            EXTRACT: { type: 'extract', label: 'Extract Data', color: '#00BCD4' },
            WAIT: { type: 'wait', label: 'Wait', color: '#FFC107' },
            CONDITION: { type: 'condition', label: 'Condition', color: '#F44336' },
            LOOP: { type: 'loop', label: 'Loop', color: '#E91E63' },
            END: { type: 'end', label: 'End', color: '#607D8B' }
        };

        // WorkflowNode Component
        function WorkflowNode({ node, onSelect, onDelete, isSelected }) {
            return (
                <div 
                    className={`workflow-node ${isSelected ? 'selected' : ''}`}
                    style={{ 
                        left: node.x, 
                        top: node.y,
                        backgroundColor: NODE_TYPES[node.type.toUpperCase()]?.color || '#ccc'
                    }}
                    onClick={() => onSelect(node)}
                >
                    <div className="node-header">
                        <span className="node-label">{node.label || NODE_TYPES[node.type.toUpperCase()]?.label}</span>
                        <button className="node-delete" onClick={(e) => { e.stopPropagation(); onDelete(node.id); }}>√ó</button>
                    </div>
                    {node.params && (
                        <div className="node-params">
                            {Object.entries(node.params).map(([key, value]) => (
                                <div key={key} className="node-param">
                                    <small>{key}: {String(value).substring(0, 20)}</small>
                                </div>
                            ))}
                        </div>
                    )}
                    <div className="node-connectors">
                        <div className="connector connector-input" data-node-id={node.id} data-type="input"></div>
                        <div className="connector connector-output" data-node-id={node.id} data-type="output"></div>
                    </div>
                </div>
            );
        }

        // NodeLibrary Component
        function NodeLibrary({ onAddNode }) {
            return (
                <div className="node-library">
                    <h3>Node Library</h3>
                    <div className="node-library-items">
                        {Object.entries(NODE_TYPES).map(([key, nodeType]) => (
                            <button
                                key={key}
                                className="node-library-item"
                                style={{ backgroundColor: nodeType.color }}
                                onClick={() => onAddNode(nodeType.type)}
                                title={`Add ${nodeType.label} node`}
                            >
                                {nodeType.label}
                            </button>
                        ))}
                    </div>
                </div>
            );
        }

        // NodeProperties Component
        function NodeProperties({ node, onUpdate, onClose }) {
            const [params, setParams] = useState(node?.params || {});

            useEffect(() => {
                setParams(node?.params || {});
            }, [node]);

            if (!node) {
                return (
                    <div className="node-properties">
                        <div className="properties-empty">
                            Select a node to edit its properties
                        </div>
                    </div>
                );
            }

            const handleParamChange = (key, value) => {
                const updated = { ...params, [key]: value };
                setParams(updated);
                onUpdate(node.id, updated);
            };

            const getParamFields = () => {
                switch (node.type) {
                    case 'navigate':
                        return [
                            { key: 'url', label: 'URL', type: 'text', placeholder: 'https://example.com' }
                        ];
                    case 'click':
                        return [
                            { key: 'selector', label: 'CSS Selector', type: 'text', placeholder: '#button' }
                        ];
                    case 'fill':
                        return [
                            { key: 'selector', label: 'CSS Selector', type: 'text', placeholder: '#input' },
                            { key: 'value', label: 'Value', type: 'text', placeholder: 'text to fill' }
                        ];
                    case 'extract':
                        return [
                            { key: 'selector', label: 'CSS Selector', type: 'text', placeholder: '.data' },
                            { key: 'attribute', label: 'Attribute', type: 'text', placeholder: 'textContent' }
                        ];
                    case 'wait':
                        return [
                            { key: 'duration', label: 'Duration (ms)', type: 'number', placeholder: '1000' }
                        ];
                    case 'condition':
                        return [
                            { key: 'condition', label: 'Condition', type: 'text', placeholder: 'data === "expected"' }
                        ];
                    default:
                        return [];
                }
            };

            return (
                <div className="node-properties">
                    <div className="properties-header">
                        <h3>Node Properties</h3>
                        <button className="close-btn" onClick={onClose}>√ó</button>
                    </div>
                    <div className="properties-content">
                        <div className="property-group">
                            <label>Node Type</label>
                            <input type="text" value={node.type} disabled />
                        </div>
                        <div className="property-group">
                            <label>Label</label>
                            <input 
                                type="text" 
                                value={node.label || ''} 
                                onChange={(e) => onUpdate(node.id, params, e.target.value)}
                                placeholder="Node label"
                            />
                        </div>
                        {getParamFields().map(field => (
                            <div key={field.key} className="property-group">
                                <label>{field.label}</label>
                                <input
                                    type={field.type}
                                    value={params[field.key] || ''}
                                    onChange={(e) => handleParamChange(field.key, e.target.value)}
                                    placeholder={field.placeholder}
                                />
                            </div>
                        ))}
                    </div>
                </div>
            );
        }

        // Canvas Component with D3 visualization
        function Canvas({ nodes, connections, onCanvasClick, selectedNode }) {
            const canvasRef = useRef(null);
            const svgRef = useRef(null);

            useEffect(() => {
                if (!svgRef.current) return;

                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();

                // Draw connections
                const g = svg.append("g");
                
                connections.forEach(conn => {
                    const fromNode = nodes.find(n => n.id === conn.from);
                    const toNode = nodes.find(n => n.id === conn.to);
                    
                    if (fromNode && toNode) {
                        // Calculate connection points
                        const x1 = fromNode.x + 100; // Node width/2
                        const y1 = fromNode.y + 40; // Node height
                        const x2 = toNode.x + 100;
                        const y2 = toNode.y;

                        // Draw curved path
                        const path = `M ${x1} ${y1} C ${x1} ${y1 + 30}, ${x2} ${y2 - 30}, ${x2} ${y2}`;
                        
                        g.append("path")
                            .attr("d", path)
                            .attr("stroke", "#666")
                            .attr("stroke-width", 2)
                            .attr("fill", "none")
                            .attr("marker-end", "url(#arrowhead)");
                    }
                });

                // Arrow marker
                svg.append("defs").append("marker")
                    .attr("id", "arrowhead")
                    .attr("markerWidth", 10)
                    .attr("markerHeight", 10)
                    .attr("refX", 5)
                    .attr("refY", 3)
                    .attr("orient", "auto")
                    .append("polygon")
                    .attr("points", "0 0, 10 3, 0 6")
                    .attr("fill", "#666");

            }, [nodes, connections]);

            return (
                <div ref={canvasRef} className="workflow-canvas" onClick={onCanvasClick}>
                    <svg ref={svgRef} className="connections-svg" />
                </div>
            );
        }

        // Main WorkflowBuilder Component
        function WorkflowBuilder() {
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [selectedNode, setSelectedNode] = useState(null);
            const [workflowName, setWorkflowName] = useState('Untitled Workflow');
            const [isDragging, setIsDragging] = useState(false);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [nextNodeId, setNextNodeId] = useState(1);
            const [currentWorkflowId, setCurrentWorkflowId] = useState(null);
            const [isExecuting, setIsExecuting] = useState(false);
            const [executionStatus, setExecutionStatus] = useState(null);
            const [executionHistory, setExecutionHistory] = useState([]);
            const [showHistory, setShowHistory] = useState(false);

            const addNode = (type) => {
                const newNode = {
                    id: `node-${nextNodeId}`,
                    type: type,
                    label: NODE_TYPES[type.toUpperCase()]?.label,
                    x: 100 + (nextNodeId * 20),
                    y: 100 + (nextNodeId * 20),
                    params: {}
                };
                setNodes([...nodes, newNode]);
                setNextNodeId(nextNodeId + 1);
                setSelectedNode(newNode);
            };

            const deleteNode = (nodeId) => {
                setNodes(nodes.filter(n => n.id !== nodeId));
                setConnections(connections.filter(c => c.from !== nodeId && c.to !== nodeId));
                if (selectedNode?.id === nodeId) {
                    setSelectedNode(null);
                }
            };

            const updateNodeParams = (nodeId, params, label) => {
                setNodes(nodes.map(node => 
                    node.id === nodeId 
                        ? { ...node, params, label: label !== undefined ? label : node.label }
                        : node
                ));
            };

            const handleCanvasClick = (e) => {
                if (e.target.className === 'workflow-canvas' || e.target.className === 'connections-svg') {
                    setSelectedNode(null);
                }
            };

            const getToken = () => {
                return localStorage.getItem('authToken') || '';
            };

            const convertNodesToWorkflow = () => {
                // Convert visual builder nodes to backend workflow format
                const tasks = nodes.map(node => {
                    const task = {
                        name: node.label || node.type,
                        agent_type: 'browser',
                        action: node.type,
                        parameters: {}
                    };

                    // Map node parameters to task parameters
                    switch (node.type) {
                        case 'navigate':
                            task.parameters = { url: node.params.url || 'https://example.com' };
                            break;
                        case 'click':
                            task.parameters = { selector: node.params.selector || 'button' };
                            break;
                        case 'fill':
                            task.parameters = { 
                                selector: node.params.selector || 'input',
                                text: node.params.value || ''
                            };
                            task.action = 'type';
                            break;
                        case 'extract':
                            task.parameters = { 
                                selector: node.params.selector || 'body'
                            };
                            task.action = 'getText';
                            break;
                        case 'wait':
                            task.parameters = { 
                                duration: parseInt(node.params.duration) || 1000
                            };
                            break;
                        case 'condition':
                            task.parameters = { 
                                condition: node.params.condition || 'true'
                            };
                            task.action = 'evaluate';
                            break;
                        default:
                            task.parameters = node.params || {};
                    }

                    return task;
                });

                return {
                    tasks,
                    variables: {},
                    on_error: 'stop'
                };
            };

            const exportWorkflow = () => {
                const workflow = {
                    name: workflowName,
                    version: '1.0',
                    nodes: nodes,
                    connections: connections,
                    createdAt: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(workflow, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${workflowName.replace(/\s+/g, '-').toLowerCase()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const importWorkflow = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const workflow = JSON.parse(event.target.result);
                        setWorkflowName(workflow.name || 'Imported Workflow');
                        setNodes(workflow.nodes || []);
                        setConnections(workflow.connections || []);
                        setNextNodeId(Math.max(...(workflow.nodes?.map(n => parseInt(n.id.split('-')[1])) || [0])) + 1);
                    } catch (error) {
                        alert('Failed to import workflow: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };

            const saveWorkflow = async () => {
                if (nodes.length === 0) {
                    alert('Please add some nodes to the workflow first');
                    return;
                }

                const workflowDefinition = convertNodesToWorkflow();
                const workflow = {
                    name: workflowName,
                    description: `Visual workflow with ${nodes.length} nodes`,
                    definition: workflowDefinition
                };

                try {
                    const token = getToken();
                    if (!token) {
                        alert('Please login first. Token not found in localStorage.');
                        return;
                    }

                    const response = await fetch('/api/v2/workflows', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(workflow)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        setCurrentWorkflowId(result.data.id);
                        alert('Workflow saved successfully!');
                    } else {
                        const error = await response.json();
                        alert('Failed to save workflow: ' + (error.error || response.statusText));
                    }
                } catch (error) {
                    alert('Error saving workflow: ' + error.message);
                }
            };

            const executeWorkflow = async () => {
                if (nodes.length === 0) {
                    alert('Please add some nodes to the workflow first');
                    return;
                }

                setIsExecuting(true);
                setExecutionStatus({ status: 'starting', message: 'Starting workflow execution...' });

                try {
                    const token = getToken();
                    if (!token) {
                        alert('Please login first. Token not found in localStorage.');
                        setIsExecuting(false);
                        return;
                    }

                    let workflowId = currentWorkflowId;

                    // If no workflow ID, create workflow first
                    if (!workflowId) {
                        const workflowDefinition = convertNodesToWorkflow();
                        const workflow = {
                            name: workflowName,
                            description: `Visual workflow with ${nodes.length} nodes`,
                            definition: workflowDefinition
                        };

                        const createResponse = await fetch('/api/v2/workflows', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify(workflow)
                        });

                        if (!createResponse.ok) {
                            throw new Error('Failed to create workflow');
                        }

                        const createResult = await createResponse.json();
                        workflowId = createResult.data.id;
                        setCurrentWorkflowId(workflowId);
                    }

                    // Execute workflow
                    const executeResponse = await fetch(`/api/v2/workflows/${workflowId}/execute`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ variables: {} })
                    });

                    if (!executeResponse.ok) {
                        throw new Error('Failed to execute workflow');
                    }

                    const executeResult = await executeResponse.json();
                    const executionId = executeResult.data.id;

                    // Start polling for status
                    pollExecutionStatus(executionId);
                } catch (error) {
                    setIsExecuting(false);
                    setExecutionStatus({ status: 'error', message: 'Execution failed: ' + error.message });
                }
            };

            const pollExecutionStatus = async (executionId) => {
                const token = getToken();
                const maxPolls = 120; // 2 minutes max
                let pollCount = 0;

                const poll = async () => {
                    try {
                        const response = await fetch(`/api/v2/executions/${executionId}/status`, {
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (!response.ok) {
                            throw new Error('Failed to get execution status');
                        }

                        const result = await response.json();
                        const { status, progress, error_message } = result.data;

                        setExecutionStatus({ 
                            status, 
                            message: `Status: ${status} (${progress}%)`,
                            progress,
                            error: error_message
                        });

                        if (status === 'completed') {
                            setIsExecuting(false);
                            // Get logs and add to history
                            await fetchExecutionLogs(executionId);
                            loadExecutionHistory();
                            return;
                        } else if (status === 'failed') {
                            setIsExecuting(false);
                            await fetchExecutionLogs(executionId);
                            loadExecutionHistory();
                            return;
                        } else if (pollCount < maxPolls) {
                            pollCount++;
                            // Exponential backoff: start at 1s, double up to 8s max
                            const delay = Math.min(1000 * Math.pow(2, Math.floor(pollCount / 3)), 8000);
                            setTimeout(poll, delay);
                        } else {
                            setIsExecuting(false);
                            setExecutionStatus({ status: 'timeout', message: 'Execution timed out' });
                        }
                    } catch (error) {
                        setIsExecuting(false);
                        setExecutionStatus({ status: 'error', message: error.message });
                    }
                };

                poll();
            };

            const fetchExecutionLogs = async (executionId) => {
                const token = getToken();
                try {
                    const response = await fetch(`/api/v2/executions/${executionId}/logs`, {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        setExecutionStatus(prev => ({
                            ...prev,
                            logs: result.data.logs
                        }));
                    }
                } catch (error) {
                    console.error('Failed to fetch logs:', error);
                }
            };

            const loadExecutionHistory = async () => {
                const token = getToken();
                if (!token) return;

                try {
                    const response = await fetch('/api/v2/workflows', {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        setExecutionHistory(result.data || []);
                    }
                } catch (error) {
                    console.error('Failed to load history:', error);
                }
            };

            useEffect(() => {
                loadExecutionHistory();
            }, []);

            return (
                <div className="workflow-builder">
                    <div className="builder-header">
                        <div className="header-left">
                            <h1>Visual Workflow Builder</h1>
                            <input 
                                type="text" 
                                className="workflow-name-input"
                                value={workflowName}
                                onChange={(e) => setWorkflowName(e.target.value)}
                                placeholder="Workflow Name"
                            />
                        </div>
                        <div className="header-right">
                            <button className="btn btn-secondary" onClick={() => setNodes([])}>Clear</button>
                            <label className="btn btn-secondary">
                                Import
                                <input type="file" accept=".json" onChange={importWorkflow} style={{display: 'none'}} />
                            </label>
                            <button className="btn btn-secondary" onClick={exportWorkflow}>Export</button>
                            <button className="btn btn-primary" onClick={saveWorkflow}>Save</button>
                            <button className="btn btn-success" onClick={executeWorkflow} disabled={isExecuting}>
                                {isExecuting ? '‚è≥ Executing...' : 'üöÄ Execute'}
                            </button>
                            <button className="btn btn-info" onClick={() => setShowHistory(!showHistory)}>
                                üìä History
                            </button>
                        </div>
                    </div>
                    
                    {executionStatus && (
                        <div className={`execution-status status-${executionStatus.status}`}>
                            <strong>{executionStatus.message}</strong>
                            {executionStatus.progress && (
                                <div className="progress-bar">
                                    <div className="progress-fill" style={{ width: `${executionStatus.progress}%` }}></div>
                                </div>
                            )}
                            {executionStatus.error && (
                                <div className="error-message">Error: {executionStatus.error}</div>
                            )}
                            {executionStatus.logs && (
                                <details className="logs-details">
                                    <summary>View Logs ({executionStatus.logs.length} entries)</summary>
                                    <div className="logs-container">
                                        {executionStatus.logs.map((log, idx) => (
                                            <div key={idx} className={`log-entry log-${log.level}`}>
                                                <span className="log-time">{new Date(log.timestamp).toLocaleTimeString()}</span>
                                                <span className="log-message">{log.message}</span>
                                            </div>
                                        ))}
                                    </div>
                                </details>
                            )}
                        </div>
                    )}
                    
                    <div className="builder-main">
                        <NodeLibrary onAddNode={addNode} />
                        
                        <div className="builder-workspace">
                            <Canvas 
                                nodes={nodes}
                                connections={connections}
                                onCanvasClick={handleCanvasClick}
                                selectedNode={selectedNode}
                            />
                            {nodes.map(node => (
                                <WorkflowNode
                                    key={node.id}
                                    node={node}
                                    onSelect={setSelectedNode}
                                    onDelete={deleteNode}
                                    isSelected={selectedNode?.id === node.id}
                                />
                            ))}
                        </div>
                        
                        <NodeProperties
                            node={selectedNode}
                            onUpdate={updateNodeParams}
                            onClose={() => setSelectedNode(null)}
                        />
                    </div>

                    {showHistory && (
                        <div className="history-panel">
                            <div className="history-header">
                                <h3>Execution History</h3>
                                <button className="btn btn-secondary" onClick={() => setShowHistory(false)}>Close</button>
                            </div>
                            <div className="history-list">
                                {executionHistory.length === 0 ? (
                                    <div className="history-empty">No workflow history yet</div>
                                ) : (
                                    executionHistory.map(workflow => (
                                        <div key={workflow.id} className="history-item">
                                            <div className="history-item-name">{workflow.name}</div>
                                            <div className="history-item-time">{new Date(workflow.created_at).toLocaleString()}</div>
                                            <div className="history-item-status">{workflow.status}</div>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>
                    )}

                    <div className="builder-footer">
                        <div className="footer-stats">
                            <span>Nodes: {nodes.length}</span>
                            <span>Connections: {connections.length}</span>
                            {currentWorkflowId && <span>ID: {currentWorkflowId.substring(0, 8)}...</span>}
                        </div>
                        <div className="footer-actions">
                            <button className="btn-link" onClick={() => window.location.href = '/dashboard.html'}>
                                Back to Dashboard
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // Render the app
        ReactDOM.render(<WorkflowBuilder />, document.getElementById('root'));
    </script>
</body>
</html>
