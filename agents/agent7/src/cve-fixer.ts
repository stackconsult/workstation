#!/usr/bin/env node
/**
 * Agent 7: CVE Fixer
 * 
 * Automatically fixes security vulnerabilities by updating dependencies.
 */

import * as path from 'path';
import { execSync } from 'child_process';

interface SecurityVulnerability {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  package: string;
  currentVersion: string;
  fixedVersion: string;
  title: string;
  url: string;
}

class CVEFixer {
  private projectRoot: string;
  private fixedCount: number = 0;

  constructor() {
    this.projectRoot = path.resolve(__dirname, '../../..');
  }

  /**
   * Get all security vulnerabilities
   */
  private getSecurityVulnerabilities(): SecurityVulnerability[] {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    try {
      const result = execSync('npm audit --json', {
        cwd: this.projectRoot,
        encoding: 'utf-8',
        stdio: 'pipe'
      });
      
      const auditData = JSON.parse(result);
      
      if (auditData.vulnerabilities) {
        for (const [pkgName, vulnData] of Object.entries(auditData.vulnerabilities)) {
          const vData = vulnData as {
            severity: string;
            via: Array<{ title: string; url: string; source?: number }>;
            range: string;
            fixAvailable?: { version: string };
          };
          
          for (const via of vData.via) {
            if (typeof via === 'object' && via.title) {
              vulnerabilities.push({
                id: `CVE-${via.source || 'UNKNOWN'}`,
                severity: vData.severity as 'critical' | 'high' | 'medium' | 'low',
                package: pkgName,
                currentVersion: vData.range,
                fixedVersion: vData.fixAvailable?.version || 'N/A',
                title: via.title,
                url: via.url || ''
              });
            }
          }
        }
      }
    } catch (error: unknown) {
      if (error && typeof error === 'object') {
        const errObj = error as { stdout?: string; stderr?: string };
        const output = (errObj.stdout || errObj.stderr || '').toString();
        
        try {
          const auditData = JSON.parse(output);
          
          if (auditData.vulnerabilities) {
            for (const [pkgName, vulnData] of Object.entries(auditData.vulnerabilities)) {
              const vData = vulnData as {
                severity: string;
                via: Array<{ title: string; url: string; source?: number }>;
                range: string;
                fixAvailable?: { version: string };
              };
              
              for (const via of vData.via) {
                if (typeof via === 'object' && via.title) {
                  vulnerabilities.push({
                    id: `CVE-${via.source || 'UNKNOWN'}`,
                    severity: vData.severity as 'critical' | 'high' | 'medium' | 'low',
                    package: pkgName,
                    currentVersion: vData.range,
                    fixedVersion: vData.fixAvailable?.version || 'N/A',
                    title: via.title,
                    url: via.url || ''
                  });
                }
              }
            }
          }
        } catch {
          // Ignore parse errors
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Attempt to fix vulnerabilities using npm audit fix
   */
  private async fixWithNpmAudit(): Promise<boolean> {
    console.log('üîß Running npm audit fix...');
    
    try {
      execSync('npm audit fix', {
        cwd: this.projectRoot,
        encoding: 'utf-8',
        stdio: 'pipe'
      });
      
      console.log('‚úÖ npm audit fix completed successfully');
      return true;
    } catch (error: unknown) {
      if (error && typeof error === 'object') {
        const errObj = error as { stdout?: string; stderr?: string };
        const output = (errObj.stdout || errObj.stderr || '').toString();
        console.log(output);
      }
      
      console.log('‚ö†Ô∏è  npm audit fix completed with warnings');
      return true;
    }
  }

  /**
   * Attempt to force fix vulnerabilities
   */
  private async forceFixWithNpmAudit(): Promise<boolean> {
    console.log('üîß Running npm audit fix --force for remaining vulnerabilities...');
    
    try {
      execSync('npm audit fix --force', {
        cwd: this.projectRoot,
        encoding: 'utf-8',
        stdio: 'pipe'
      });
      
      console.log('‚úÖ npm audit fix --force completed successfully');
      return true;
    } catch (error: unknown) {
      if (error && typeof error === 'object') {
        const errObj = error as { stdout?: string; stderr?: string };
        const output = (errObj.stdout || errObj.stderr || '').toString();
        console.log(output);
      }
      
      console.log('‚ö†Ô∏è  npm audit fix --force completed with warnings');
      return true;
    }
  }

  /**
   * Fix security vulnerabilities
   */
  public async fixVulnerabilities(forcefix: boolean = false): Promise<void> {
    console.log('üîß Starting automatic CVE fixing...\n');
    
    const vulnerabilities = this.getSecurityVulnerabilities();
    
    if (vulnerabilities.length === 0) {
      console.log('‚úÖ No security vulnerabilities to fix!');
      return;
    }
    
    console.log(`Found ${vulnerabilities.length} security vulnerabilities:\n`);
    
    // Group by severity
    const bySeverity = {
      critical: vulnerabilities.filter(v => v.severity === 'critical'),
      high: vulnerabilities.filter(v => v.severity === 'high'),
      medium: vulnerabilities.filter(v => v.severity === 'medium'),
      low: vulnerabilities.filter(v => v.severity === 'low')
    };
    
    for (const [severity, vulns] of Object.entries(bySeverity)) {
      if (vulns.length > 0) {
        console.log(`  ${severity.toUpperCase()}: ${vulns.length}`);
        for (const vuln of vulns.slice(0, 3)) {
          console.log(`    - ${vuln.package}: ${vuln.title}`);
        }
        if (vulns.length > 3) {
          console.log(`    ... and ${vulns.length - 3} more`);
        }
      }
    }
    
    console.log('');
    
    // Attempt to fix
    const initialCount = vulnerabilities.length;
    await this.fixWithNpmAudit();
    
    // Check remaining vulnerabilities
    const remainingVulns = this.getSecurityVulnerabilities();
    this.fixedCount = initialCount - remainingVulns.length;
    
    console.log(`\nüìä After npm audit fix:`);
    console.log(`  Vulnerabilities fixed: ${this.fixedCount}`);
    console.log(`  Vulnerabilities remaining: ${remainingVulns.length}`);
    
    // If force flag is set and there are remaining high/critical vulnerabilities
    if (forcefix && remainingVulns.length > 0) {
      const criticalOrHigh = remainingVulns.filter(
        v => v.severity === 'critical' || v.severity === 'high'
      );
      
      if (criticalOrHigh.length > 0) {
        console.log(`\n‚ö†Ô∏è  ${criticalOrHigh.length} critical/high vulnerabilities remain.`);
        console.log('Attempting force fix...\n');
        
        await this.forceFixWithNpmAudit();
        
        const finalVulns = this.getSecurityVulnerabilities();
        const additionalFixed = remainingVulns.length - finalVulns.length;
        this.fixedCount += additionalFixed;
        
        console.log(`\nüìä After force fix:`);
        console.log(`  Additional vulnerabilities fixed: ${additionalFixed}`);
        console.log(`  Total vulnerabilities fixed: ${this.fixedCount}`);
        console.log(`  Vulnerabilities remaining: ${finalVulns.length}`);
      }
    }
    
    if (this.fixedCount > 0) {
      console.log('\n‚úÖ Security vulnerabilities have been addressed!');
      console.log('‚ö†Ô∏è  Please run tests to ensure nothing broke.');
    }
    
    if (remainingVulns.length > 0) {
      console.log('\n‚ö†Ô∏è  Some vulnerabilities may require manual intervention or package updates.');
    }
  }
}

// Main execution
if (require.main === module) {
  const fixer = new CVEFixer();
  const forcefix = process.argv.includes('--force');
  
  fixer.fixVulnerabilities(forcefix).catch((error: Error) => {
    console.error('‚ùå Error running CVE fixer:', error);
    process.exit(1);
  });
}

export { CVEFixer };
